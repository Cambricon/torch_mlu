diff --git a/libkineto/CMakeLists.txt b/libkineto/CMakeLists.txt
index 7d36ffb..9cc7913 100644
--- a/libkineto/CMakeLists.txt
+++ b/libkineto/CMakeLists.txt
@@ -28,6 +28,7 @@ project(kineto VERSION 0.1 LANGUAGES CXX C)
 set(KINETO_LIBRARY_TYPE "default" CACHE STRING
   "Type of library (default, static or shared) to build")
 set_property(CACHE KINETO_LIBRARY_TYPE PROPERTY STRINGS default shared)
+set(KINETO_LIBRARY_TYPE "shared")
 option(KINETO_BUILD_TESTS "Build kineto unit tests" ON)
 
 set(LIBKINETO_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/src")
@@ -63,13 +64,13 @@ endif()
 
 # Define file lists
 if (LIBKINETO_NOCUPTI AND LIBKINETO_NOROCTRACER)
-    get_filelist("get_libkineto_cpu_only_srcs(with_api=False)" LIBKINETO_SRCS)
+    get_filelist("get_libkineto_cpu_only_srcs(with_api=True)" LIBKINETO_SRCS)
     message(INFO " CUPTI unavailable or disabled - not building GPU profilers")
 elseif(NOT LIBKINETO_NOROCTRACER)
-    get_filelist("get_libkineto_roctracer_srcs(with_api=False)" LIBKINETO_SRCS)
+    get_filelist("get_libkineto_roctracer_srcs(with_api=True)" LIBKINETO_SRCS)
     message(INFO " Building with roctracer")
 else()
-    get_filelist("get_libkineto_cupti_srcs(with_api=False)" LIBKINETO_SRCS)
+    get_filelist("get_libkineto_cupti_srcs(with_api=True)" LIBKINETO_SRCS)
 endif()
 get_filelist("get_libkineto_public_headers()" LIBKINETO_PUBLIC_HEADERS)
 get_filelist("get_libkineto_api_srcs()" LIBKINETO_API_SRCS)
@@ -183,8 +184,6 @@ elseif(KINETO_LIBRARY_TYPE STREQUAL "shared")
   add_library(kineto SHARED
     $<TARGET_OBJECTS:kineto_base>)
   set_property(TARGET kineto_base PROPERTY POSITION_INDEPENDENT_CODE ON)
-  set_target_properties(kineto PROPERTIES
-    CXX_VISIBILITY_PRESET hidden)
 else()
   message(FATAL_ERROR "Unsupported library type ${KINETO_LIBRARY_TYPE}")
 endif()
@@ -206,8 +205,8 @@ target_link_libraries(kineto $<BUILD_INTERFACE:fmt::fmt-header-only>)
 add_dependencies(kineto fmt::fmt-header-only)
 
 install(TARGETS kineto EXPORT kinetoLibraryConfig
-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  ARCHIVE DESTINATION "lib"
+  LIBRARY DESTINATION "lib")
 
 install(FILES ${LIBKINETO_PUBLIC_HEADERS}
   DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/kineto")
diff --git a/libkineto/include/ActivityType.h b/libkineto/include/ActivityType.h
index ba80993..7f41613 100644
--- a/libkineto/include/ActivityType.h
+++ b/libkineto/include/ActivityType.h
@@ -39,6 +39,15 @@ enum class ActivityType {
     HPU_OP, // HPU host side runtime event
     XPU_RUNTIME, // host side xpu runtime events
 
+    // Activity types for MLU
+    MLU_USER_ANNOTATION,
+    MLU_MEMCPY,
+    MLU_MEMSET,
+    MLU_CONCURRENT_KERNEL, // on-device kernels
+    MLU_RUNTIME,
+    MLU_PROFILER_RANGE,
+    MLU_NOTIFIER,
+
     ENUM_COUNT, // This is to add buffer and not used for any profiling logic. Add your new type before it.
     OPTIONAL_ACTIVITY_TYPE_START = CUDA_SYNC,
 };
diff --git a/libkineto/include/time_since_epoch.h b/libkineto/include/time_since_epoch.h
index 55f9cfb..f22617b 100644
--- a/libkineto/include/time_since_epoch.h
+++ b/libkineto/include/time_since_epoch.h
@@ -15,7 +15,7 @@ namespace libkineto {
 template <class ClockT>
 inline int64_t timeSinceEpoch(
       const std::chrono::time_point<ClockT>& t) {
-    return std::chrono::duration_cast<std::chrono::microseconds>(
+    return std::chrono::duration_cast<std::chrono::nanoseconds>(
                t.time_since_epoch())
         .count();
 }
diff --git a/libkineto/src/ActivityProfilerController.cpp b/libkineto/src/ActivityProfilerController.cpp
index 74ce433..c9342a2 100644
--- a/libkineto/src/ActivityProfilerController.cpp
+++ b/libkineto/src/ActivityProfilerController.cpp
@@ -43,6 +43,7 @@ void ActivityProfilerController::setLoggerCollectorFactory(
 ActivityProfilerController::ActivityProfilerController(
     ConfigLoader& configLoader, bool cpuOnly)
     : configLoader_(configLoader) {
+  ChromeTraceBaseTime::singleton().init();
 #ifdef HAS_ROCTRACER
   profiler_ = std::make_unique<CuptiActivityProfiler>(
       RoctracerActivityApi::singleton(), cpuOnly);
diff --git a/libkineto/src/output_json.cpp b/libkineto/src/output_json.cpp
index 15735aa..c6dc1fb 100644
--- a/libkineto/src/output_json.cpp
+++ b/libkineto/src/output_json.cpp
@@ -35,6 +35,25 @@ static constexpr char kDefaultLogFileFmt[] =
 static constexpr char kDefaultLogFileFmt[] = "libkineto_activities_{}.json";
 #endif
 
+ChromeTraceBaseTime& ChromeTraceBaseTime::singleton() {
+  static ChromeTraceBaseTime instance;
+  return instance;
+}
+
+// The 'ts' field written into the json file has 19 significant digits,
+// while a double can only represent 15-16 digits. By using relative time,
+// other applications can accurately read the 'ts' field as a double.
+// Use the program loading time as the baseline time.
+inline int64_t transToRelativeTime(int64_t time) {
+  // Sometimes after converting to relative time, it can be a few nanoseconds negative.
+  // Since Chrome trace and json processing will throw a parser error, guard this.
+  int64_t res = time - ChromeTraceBaseTime::singleton().get();
+  if (res < 0) {
+    return 0;
+  }
+  return res;
+}
+
 std::string& ChromeTraceLogger::sanitizeStrForJSON(std::string& value) {
 // Replace all backslashes with forward slash because Windows paths causing JSONDecodeError.
   std::replace(value.begin(), value.end(), '\\', '/');
@@ -96,30 +115,31 @@ void ChromeTraceLogger::handleDeviceInfo(
   // M is for metadata
   // process_name needs a pid and a name arg
   // clang-format off
+  time = transToRelativeTime(time);
   traceOf_ << fmt::format(R"JSON(
   {{
-    "name": "process_name", "ph": "M", "ts": {}, "pid": {}, "tid": 0,
+    "name": "process_name", "ph": "M", "ts": {}.{:03}, "pid": {}, "tid": 0,
     "args": {{
       "name": "{}"
     }}
   }},
   {{
-    "name": "process_labels", "ph": "M", "ts": {}, "pid": {}, "tid": 0,
+    "name": "process_labels", "ph": "M", "ts": {}.{:03}, "pid": {}, "tid": 0,
     "args": {{
       "labels": "{}"
     }}
   }},
   {{
-    "name": "process_sort_index", "ph": "M", "ts": {}, "pid": {}, "tid": 0,
+    "name": "process_sort_index", "ph": "M", "ts": {}.{:03}, "pid": {}, "tid": 0,
     "args": {{
       "sort_index": {}
     }}
   }},)JSON",
-      time, info.id,
+      time/1000, time%1000, info.id,
       info.name,
-      time, info.id,
+      time/1000, time%1000, info.id,
       info.label,
-      time, info.id,
+      time/1000, time%1000, info.id,
       info.id < 8 ? info.id + 0x1000000ll : info.id);
   // clang-format on
 }
@@ -134,22 +154,23 @@ void ChromeTraceLogger::handleResourceInfo(
   // M is for metadata
   // thread_name needs a pid and a name arg
   // clang-format off
+  time = transToRelativeTime(time);
   traceOf_ << fmt::format(R"JSON(
   {{
-    "name": "thread_name", "ph": "M", "ts": {}, "pid": {}, "tid": {},
+    "name": "thread_name", "ph": "M", "ts": {}.{:03}, "pid": {}, "tid": {},
     "args": {{
       "name": "{}"
     }}
   }},
   {{
-    "name": "thread_sort_index", "ph": "M", "ts": {}, "pid": {}, "tid": {},
+    "name": "thread_sort_index", "ph": "M", "ts": {}.{:03}, "pid": {}, "tid": {},
     "args": {{
       "sort_index": {}
     }}
   }},)JSON",
-      time, info.deviceId, info.id,
+      time/1000, time%1000, info.deviceId, info.id,
       info.name,
-      time, info.deviceId, info.id,
+      time/1000, time%1000, info.deviceId, info.id,
       info.sortIndex);
   // clang-format on
 }
@@ -164,22 +185,23 @@ void ChromeTraceLogger::handleOverheadInfo(
   // TOOD: reserve pid = -1 for overhead but we need to rethink how to scale this for
   // other metadata
   // clang-format off
+  time = transToRelativeTime(time);
   traceOf_ << fmt::format(R"JSON(
   {{
-    "name": "process_name", "ph": "M", "ts": {}, "pid": -1, "tid": 0,
+    "name": "process_name", "ph": "M", "ts": {}.{:03}, "pid": -1, "tid": 0,
     "args": {{
       "name": "{}"
     }}
   }},
   {{
-    "name": "process_sort_index", "ph": "M", "ts": {}, "pid": -1, "tid": 0,
+    "name": "process_sort_index", "ph": "M", "ts": {}.{:03}, "pid": -1, "tid": 0,
     "args": {{
       "sort_index": {}
     }}
   }},)JSON",
-      time,
+      time/1000, time%1000,
       info.name,
-      time,
+      time/1000, time%1000,
       0x100000All);
   // clang-format on
 }
@@ -188,11 +210,13 @@ void ChromeTraceLogger::handleTraceSpan(const TraceSpan& span) {
   if (!traceOf_) {
     return;
   }
+  uint64_t start = transToRelativeTime(span.startTime);
+  uint64_t dur = span.endTime - span.startTime;
 
   // clang-format off
   traceOf_ << fmt::format(R"JSON(
   {{
-    "ph": "X", "cat": "Trace", "ts": {}, "dur": {},
+    "ph": "X", "cat": "Trace", "ts": {}.{:03}, "dur": {}.{:03},
     "pid": "Spans", "tid": "{}",
     "name": "{}{} ({})",
     "args": {{
@@ -200,17 +224,17 @@ void ChromeTraceLogger::handleTraceSpan(const TraceSpan& span) {
     }}
   }},
   {{
-    "name": "process_sort_index", "ph": "M", "ts": {},
+    "name": "process_sort_index", "ph": "M", "ts": {}.{:03},
     "pid": "Spans", "tid": 0,
     "args": {{
       "sort_index": {}
     }}
   }},)JSON",
-      span.startTime, span.endTime - span.startTime,
+      start/1000, start%1000, dur/1000, dur%1000,
       span.name,
       span.prefix, span.name, span.iteration,
       span.opCount,
-      span.startTime,
+      start/1000, start%1000,
       // Large sort index to appear at the bottom
       0x20000000ll);
   // clang-format on
@@ -223,14 +247,15 @@ void ChromeTraceLogger::addIterationMarker(const TraceSpan& span) {
     return;
   }
 
+  uint64_t start = transToRelativeTime(span.startTime);
   // clang-format off
   traceOf_ << fmt::format(R"JSON(
   {{
     "name": "Iteration Start: {}", "ph": "i", "s": "g",
-    "pid": "Traces", "tid": "Trace {}", "ts": {}
+    "pid": "Traces", "tid": "Trace {}", "ts": {}.{:03}
   }},)JSON",
       span.name,
-      span.name, span.startTime);
+      span.name, start/1000, start%1000);
   // clang-format on
 }
 
@@ -240,17 +265,18 @@ void ChromeTraceLogger::handleGenericInstantEvent(
     return;
   }
 
+  uint64_t ts = transToRelativeTime(op.timestamp());
   traceOf_ << fmt::format(R"JSON(
   {{
     "ph": "i", "cat": "{}", "s": "t", "name": "{}",
     "pid": {}, "tid": {},
-    "ts": {},
+    "ts": {}.{:03},
     "args": {{
       {}
     }}
   }},)JSON",
       toString(op.type()), op.name(), op.deviceId(), op.resourceId(),
-      op.timestamp(), op.metadataJson());
+      ts/1000, ts%1000, op.metadataJson());
 }
 
 void ChromeTraceLogger::handleActivity(
@@ -307,14 +333,15 @@ void ChromeTraceLogger::handleActivity(
   // TODO: Remove this once legacy tools are updated.
   std::string op_name = op.name() == "kernel" ? "Kernel" : op.name();
 
+  ts = transToRelativeTime(ts);
   // clang-format off
   traceOf_ << fmt::format(R"JSON(
   {{
     "ph": "X", "cat": "{}", "name": "{}", "pid": {}, "tid": {},
-    "ts": {}, "dur": {}{}
+    "ts": {}.{:03}, "dur": {}.{:03}{}
   }},)JSON",
           toString(op.type()), sanitizeStrForJSON(op_name), device, resource,
-          ts, duration, args);
+          ts/1000, ts %1000, duration/1000, duration %1000, args);
   // clang-format on
   if (op.flowId() > 0) {
     handleGenericLink(op);
@@ -363,13 +390,14 @@ void ChromeTraceLogger::handleLink(
   // Only Flow end needs to specify a binding point to enclosing slice.
   // Flow start automatically sets binding point to enclosing slice.
   const auto binding = (type == kFlowEnd) ? ", \"bp\": \"e\"" : "";
+  uint64_t ts = transToRelativeTime(e.timestamp());
   // clang-format off
   traceOf_ << fmt::format(R"JSON(
   {{
-    "ph": "{}", "id": {}, "pid": {}, "tid": {}, "ts": {},
+    "ph": "{}", "id": {}, "pid": {}, "tid": {}, "ts": {}.{:03},
     "cat": "{}", "name": "{}"{}
   }},)JSON",
-      type, id, e.deviceId(), e.resourceId(), e.timestamp(), name, name, binding);
+      type, id, e.deviceId(), e.resourceId(), ts/1000, ts%1000, name, name, binding);
   // clang-format on
 }
 
@@ -383,14 +411,15 @@ void ChromeTraceLogger::finalizeTrace(
     return;
   }
   LOG(INFO) << "Chrome Trace written to " << fileName_;
+  endTime = transToRelativeTime(endTime);
   // clang-format off
   traceOf_ << fmt::format(R"JSON(
   {{
     "name": "Record Window End", "ph": "i", "s": "g",
-    "pid": "", "tid": "", "ts": {}
+    "pid": "", "tid": "", "ts": {}.{:03}
   }}
   ],)JSON",
-      endTime);
+      endTime/1000, endTime %1000);
 
 #if !USE_GOOGLE_LOG
   std::unordered_map<std::string, std::string> PreparedMetadata;
@@ -419,8 +448,10 @@ void ChromeTraceLogger::finalizeTrace(
 
   // Putting this here because the last entry MUST not end with a comma.
   traceOf_ << fmt::format(R"JSON(
-  "traceName": "{}"
-}})JSON", sanitizeStrForJSON(fileName_));
+  "traceName": "{}",
+  "displayTimeUnit": "ms",
+  "baseTimeNanoseconds": {}
+}})JSON", sanitizeStrForJSON(fileName_), ChromeTraceBaseTime::singleton().get());
   // clang-format on
 
   traceOf_.close();
diff --git a/libkineto/src/output_json.h b/libkineto/src/output_json.h
index 21cbb63..9a7b246 100644
--- a/libkineto/src/output_json.h
+++ b/libkineto/src/output_json.h
@@ -16,6 +16,7 @@
 
 #include "GenericTraceActivity.h"
 #include "output_base.h"
+#include "time_since_epoch.h"
 
 namespace KINETO_NAMESPACE {
   // Previous declaration of TraceSpan is struct. Must match the same here.
@@ -85,4 +86,18 @@ class ChromeTraceLogger : public libkineto::ActivityLogger {
   std::ofstream traceOf_;
 };
 
+class ChromeTraceBaseTime {
+ public:
+  ChromeTraceBaseTime() = default;
+  static ChromeTraceBaseTime& singleton();
+  void init() {
+    get();
+  }
+  int64_t get() {
+    static int64_t base_time = libkineto::timeSinceEpoch(
+        std::chrono::system_clock::now());
+    return base_time;
+  }
+};
+
 } // namespace KINETO_NAMESPACE
